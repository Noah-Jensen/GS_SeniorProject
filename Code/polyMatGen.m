function [MonomSeries, DomSeries, TromLSeries, TromISeries, TetromISeries, TetromSqSeries, TetromTSeries, TetromZSeries, TetromLSeries, PolyNum] = polyMatGen(v)
%[MonomSeries, DomSeries, TromLSeries, TromISeries, TetromISeries, TetromSqSeries, TetromTSeries, TetromZSeries, TetromLSeries, PolyNum] = polyMatGen(v)
%
%
%   OUTPUTS
%
%   MonomSeries is the matrix that is a size of 6x6xL, where L is the
%   number of possible monomino positions. It should contain all the valid
%   positions for Monominoes on the board generated by v.
%
%   DomSeries is the matrix that is a size of 6x6xL, where L is the number
%   of possible domino positions. It should contain all the valid positions
%   for dominoes on the board generated by v.
%
%   TromLSeries is the matrix that is a size of 6x6xL, where L is the
%   number of possible L-shape tromino positions. It should contain all the
%   valid positions for L-shape trominoes on the board generated by v.
%
%   TromISeries is the matrix that is a size of 6x6xL, where L is the
%   number of possible I-shape tromino positions. It should contain all the
%   valid positions for I-shape trominoes on the board generated by v.
%
%   TetromISeries is the matrix that is a size of 6x6xL, where L is the
%   number of possible I-shape tetromino positions. It should contain all the
%   valid positions for I-shape tetrominoes on the board generated by v.
%
%   TetromSqSeries is the matrix that is a size of 6x6xL, where L is the
%   number of possible square-shape tetromino positions. It should contain all the
%   valid positions for square-shape tetrominoes on the board generated by v.
%
%   TetromTSeries is the matrix that is a size of 6x6xL, where L is the
%   number of possible T-shape tetromino positions. It should contain all the
%   valid positions for T-shape tetrominoes on the board generated by v.
%
%   TetromZSeries is the matrix that is a size of 6x6xL, where L is the
%   number of possible Z-shape tetromino positions. It should contain all the
%   valid positions for Z-shape tetrominoes on the board generated by v.
%
%   TetromLSeries is the matrix that is a size of 6x6xL, where L is the
%   number of possible L-shape tetromino positions. It should contain all the
%   valid positions for L-shape tetrominoes on the board generated by v.
%
%   PolyNum is the total number of possible polyomino positions,
%   effectively the L length of each series matrix added together.
%
%
%   INPUT
%
%   v is the vector which contains the locations of the blockers. These
%   locations are pairs which point to matrix entries as Row x Column,
%   where Row 1 is the topmost row and Column 1 is the Leftmost row.
%
%
%   HOW IT WORKS
%
%   First a 6x6 of all ones and one of all zeros is generated. They are
%   called for many times so this will be handy.
%
%   Next, a 6x6 matrix of zeros with ones where blockers are is generated.
%
%   This is followed by the generation of the Monomino series. This is done
%   by creating matrices and checking whether or not each position would
%   overlap with a blocker.
%
%   This process is repeated for each polyomino series.
%
%   Originally, while the process is going, a locator vector is created for
%   each type of polyomino which indicates where there was overlap. This is
%   changed at the end to indicate where there was no overlap.
%
%   Each series then has space allocated for it, and is subsequently filled
%   with the possible board positions for each polyomino. 
%
%   Finally the total number of board positions is stored in PolyNum




zer = zeros(6,6);
Os = ones(6,6);


%Generating a blocker matrix with 1s where blockers are.
B = zeros(6,6);

for p = 1:7
    B(v(p,1),v(p,2)) = 1;
end

%%
%Generating for the monomino. Creates a list of Matrices M, where the third
%entry is the index of the matrix and the first and second entries are the
%rows and columns of the board respectively.


MCount = 0; %Counts number of matrices with overlapping blockers/monominoes
MLoc = zeros(36,1); %Locator vector. It is one when there is an overlap.
Monom = zeros(6,6,36); %Preallocating for all the matrices to be generated.


for t = 0:35

    col = mod(t,6)+1; %first cycles through the columns then once the column is finished, goes onto the next row.
    row = floor((t)/6+1);

    if B(row,col) == 0
        Monom(row,col,t+1) = 1;
    
    elseif B(row,col) == 1
        Monom(:,:,t+1) = 1;
        MCount = MCount + 1;
        MLoc(t+1,1) = 1;

    end

end

%%
%Generating for the domino. Similar to the monomino this creates a list of
%matrices, the third entry is the index, the first and second are rows and
%columns respectively for the matrix corresponding to the board.

DCount = 0; %Number of matrices with overlapping blocker/dominoes
DLoc = zeros(60,1); %Locator vector: 1 is an overlap.

Dom = zeros(6,6,60); %Preallocation

%horizontal dominoes


for p = 0:29

DomPH = zer; %Placeholder matrix that will hold what the domino would look like on the board

row = floor(p/5)+1; %cycles columns then rows
col = mod(p,5)+1;

DomPH(row,col) = 1; %placing the domino on the placeholder matrix
DomPH(row,col+1) = 1;



C = DomPH + B; 
Two = sum(ismember(C, 2)); %checking if the sum of the dummy board and the placeholder domino matrix has a 2 anywhere. if it does, there is an overlap.


if Two == 0
    
    Dom(:,:,p+1) = DomPH;

else

    Dom(:,:,p+1) = Os;
    DCount = DCount + 1;
    DLoc(p+1,1) = 1;

end


end

%Vertical Dominoes

for p = 0:29

    DomPH = zer;

    row = floor(p/6)+1;
    col = mod(p,6)+1;

    DomPH(row,col) = 1;
    DomPH(row+1,col) = 1;

    C = DomPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Dom(:,:,p+31)=DomPH; %the +31 here takes into account that this starts on the 31st entry of Dom, since the first 30 are taken by horizontal dominoes
    else
        Dom(:,:,p+31) = Os;
        DCount = DCount + 1;
        DLoc(p+31,1) = 1;
    end

end

%%
%Generating a matrix similarly to monominoes and dominoes for trominoes, a list of
%matrices with the first two entries corresponding to the board and the 3rd
%entry acting as an index.

TrCount = 0; %Number of matrices with overlapping trominoes/blockers
TrLoc = zeros(148,1); %Locator: 1 means there was an overlap
Trom = zeros(6,6,148); %preallocation
TrICount = 0; %Counter for the number of matrices with NO overlap for the I tromino
TrLCount = 0; %Counter for the number of matrices with NO overlap for the L tromino


%First do the I trominoes

%Horizontal 

for p = 0:23

    TromPH = zer; %Placeholder that will have the tromino placed on it.

    row = floor(p/4)+1;
    col = mod(p,4)+1;

    TromPH(row, col) = 1; %placing the tromino on the placeholder matrix.
    TromPH(row, col + 1) = 1;
    TromPH(row, col + 2) = 1;

    C = TromPH + B;
    Two = sum(ismember(C,2)); %checking if there is overlap

    if Two == 0
        Trom(:,:,p+1) = TromPH;
        TrICount = TrICount + 1; %incrementing the counter which tells how many I tromino locations there are.
    else
        Trom(:,:,p+1) = Os;
        TrCount = TrCount + 1;
        TrLoc(p+1,1) = 1;
    end


end

%Vertical

for p = 0:23

    TromPH = zer;

    row = floor(p/6)+1;
    col = mod(p,6)+1;

    TromPH(row, col) = 1;
    TromPH(row + 1, col) = 1;
    TromPH(row + 2, col) = 1;

    C = TromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Trom(:,:,p+25) = TromPH;
        TrICount = TrICount + 1;
    else
        Trom(:,:,p+25) = Os;
        TrCount = TrCount + 1;
        TrLoc(p+25,1) = 1;
    end


end

% L shaped done by missing quadrant (same quadrants as R^2)

%missing 1st Quad

for p = 0:24
    
    TromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TromPH(row, col) = 1;
    TromPH(row + 1, col) = 1;
    TromPH(row + 1, col + 1) = 1;
    
    C = TromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0 
        Trom(:,:,p+49) = TromPH;
        TrLCount = TrLCount + 1;
    else
        Trom(:,:,p+49) = Os;
        TrCount = TrCount + 1;
        TrLoc(p+49,1) = 1;
    end
    
end

%missing 2nd Quad

for p = 0:24
    
    TromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TromPH(row, col + 1) = 1;
    TromPH(row + 1, col) = 1;
    TromPH(row + 1, col + 1) = 1;
    
    C = TromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0 
        Trom(:,:,p+74) = TromPH;
        TrLCount = TrLCount + 1;
    else
        Trom(:,:,p+74) = Os;
        TrCount = TrCount + 1;
        TrLoc(p+74,1) = 1;
    end
    
end

%missing 3rd Quad

for p = 0:24
    
    TromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TromPH(row, col) = 1;
    TromPH(row, col + 1) = 1;
    TromPH(row + 1, col + 1) = 1;
    
    C = TromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0 
        Trom(:,:,p+99) = TromPH;
        TrLCount = TrLCount + 1;
    else
        Trom(:,:,p+99) = Os;
        TrCount = TrCount + 1;
        TrLoc(p+99,1) = 1;
    end
    
end

%missing 4th Quad

for p = 0:24
    
    TromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TromPH(row, col) = 1;
    TromPH(row + 1, col) = 1;
    TromPH(row, col + 1) = 1;
    
    C = TromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0 
        Trom(:,:,p+124) = TromPH;
        TrLCount = TrLCount + 1;
    else
        Trom(:,:,p+124) = Os;
        TrCount = TrCount + 1;
        TrLoc(p+124) = 1;
    end
    
end

%%
%Making matrices for tetrominoes similarly to all previous ones. first two
%elements make up the board, the third is an index.

TeCount = 0; %Count of matrices where there is overlap
TeLoc = zeros(381,1); %Locator with 1 where there is overlap.
Tetrom = zeros(6,6,381); %preallocation

TeICount = 0; %these all count the number of tetrominoes that were successfully placed for their respective shape.
TeLCount = 0;
TeSqCount = 0;
TeZCount = 0;
TeTCount = 0;




%I Horizontal

for p = 0:17

    TetromPH = zer;

    row = floor(p/3)+1;
    col = mod(p,3)+1;

    TetromPH(row, col) = 1;
    TetromPH(row, col + 1) = 1;
    TetromPH(row, col + 2) = 1;
    TetromPH(row, col + 3) = 1;

    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+1) = TetromPH;
        TeICount = TeICount + 1;
    else
        Tetrom(:,:,p+1) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+1) = 1;
    end

end


%I Vertical

for p = 0:17

    TetromPH = zer;

    row = floor(p/6)+1;
    col = mod(p,6)+1;

    TetromPH(row, col) = 1;
    TetromPH(row + 1, col) = 1;
    TetromPH(row + 2, col) = 1;
    TetromPH(row + 3, col) = 1;

    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+19) = TetromPH;
        TeICount = TeICount + 1;
    else
        Tetrom(:,:,p+19) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+19) = 1;
    end

end

%square

for p = 0:24

    TetromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TetromPH(row, col) = 1;
    TetromPH(row, col + 1) = 1;
    TetromPH(row + 1, col) = 1;
    TetromPH(row + 1, col +1) = 1;

    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+37) = TetromPH;
        TeSqCount = TeSqCount + 1;
    else
        Tetrom(:,:,p+37) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+37) = 1;
    end

end

% T

% Same as normal capital T

for p = 0:19

    TetromPH = zer;

    row = floor(p/4)+1;
    col = mod(p,4)+1;

    TetromPH(row, col) = 1;
    TetromPH(row, col + 1) = 1;
    TetromPH(row, col + 2) = 1;
    TetromPH(row + 1, col + 1) = 1;

    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+62) = TetromPH;
        TeTCount = TeTCount + 1;
    else
        Tetrom(:,:,p+62) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+62) = 1;
    end
end

% T rotated 90 deg ccw

for p = 0:19

    TetromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TetromPH(row, col) = 1;
    TetromPH(row + 1, col) = 1;
    TetromPH(row + 2, col) = 1;
    TetromPH(row + 1, col + 1) = 1;

    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+82) = TetromPH;
        TeTCount = TeTCount + 1;
    else
        Tetrom(:,:,p+82) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+82) = 1;
    end
end

% T rotated 180 

for p = 0:19

    TetromPH = zer;

    row = floor(p/4)+1;
    col = mod(p,4)+1;

    TetromPH(row + 1, col) = 1;
    TetromPH(row, col + 1) = 1;
    TetromPH(row + 1, col + 2) = 1;
    TetromPH(row + 1, col + 1) = 1;

    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+102) = TetromPH;
        TeTCount = TeTCount + 1;
    else
        Tetrom(:,:,p+102) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+102) = 1;
    end
end


% T rotated 90 deg cw

for p = 0:19

    TetromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TetromPH(row, col + 1) = 1;
    TetromPH(row + 1, col) = 1;
    TetromPH(row + 2, col + 1) = 1;
    TetromPH(row + 1, col + 1) = 1;

    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+122) = TetromPH;
        TeTCount = TeTCount + 1;
    else
        Tetrom(:,:,p+122) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+122) = 1;
    end
end

%Z First with Z orientation, then with flipped orientation

%Z

for p = 0:19

    TetromPH = zer;

    row = floor(p/4)+1;
    col = mod(p,4)+1;

    TetromPH(row, col) = 1;
    TetromPH(row, col + 1) = 1;
    TetromPH(row + 1, col + 1) = 1;
    TetromPH(row + 1, col + 2) = 1;

    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+142) = TetromPH;
        TeZCount = TeZCount + 1;
    else
        Tetrom(:,:,p+142) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+142) = 1;
    end
end


%Z rotated 90 deg

for p = 0:19

    TetromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TetromPH(row, col + 1) = 1;
    TetromPH(row + 1, col + 1) = 1;
    TetromPH(row + 1, col) = 1;
    TetromPH(row + 2, col) = 1;

    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+162) = TetromPH;
        TeZCount = TeZCount + 1;
    else
        Tetrom(:,:,p+162) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+162) = 1;
    end
end


%Z flipped

for p = 0:19

    TetromPH = zer;

    row = floor(p/4)+1;
    col = mod(p,4)+1;

    TetromPH(row + 1, col) = 1;
    TetromPH(row, col + 1) = 1;
    TetromPH(row + 1, col + 1) = 1;
    TetromPH(row, col + 2) = 1;

    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+182) = TetromPH;
        TeZCount = TeZCount + 1;
    else
        Tetrom(:,:,p+182) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+182) = 1;
    end
end

%Z flipped rotated 90 deg

for p = 0:19

    TetromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TetromPH(row, col) = 1;
    TetromPH(row + 1, col + 1) = 1;
    TetromPH(row + 1, col) = 1;
    TetromPH(row + 2, col + 1) = 1;

    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+202) = TetromPH;
        TeZCount = TeZCount + 1;
    else
        Tetrom(:,:,p+202) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+202) = 1;
    end
end


%L section, starting with L and its rotations, then flipped L and its
%rotations

%L

for p = 0:19

    TetromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TetromPH(row, col) = 1;
    TetromPH(row + 1, col) = 1;
    TetromPH(row + 2, col) = 1;
    TetromPH(row + 2, col + 1) = 1;
    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+222) = TetromPH;
        TeLCount = TeLCount + 1;
    else
        Tetrom(:,:,p+222) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+222) = 1;
    end
end


%L rotate 90 deg ccw

for p = 0:19

    TetromPH = zer;

    row = floor(p/4)+1;
    col = mod(p,4)+1;

    TetromPH(row + 1, col) = 1;
    TetromPH(row + 1, col + 1) = 1; 
    TetromPH(row + 1, col + 2) = 1;
    TetromPH(row, col + 2) = 1;
    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+242) = TetromPH;
        TeLCount = TeLCount + 1;
    else
        Tetrom(:,:,p+242) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+242) = 1;
    end
end

%L 180 deg rotation

for p = 0:19

    TetromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TetromPH(row, col) = 1;
    TetromPH(row, col + 1) = 1;
    TetromPH(row + 1, col + 1) = 1;
    TetromPH(row + 2, col + 1) = 1;
    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+262) = TetromPH;
        TeLCount = TeLCount + 1;
    else
        Tetrom(:,:,p+262) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+262) = 1;
    end
end

%L 90 deg cw rotation

for p = 0:19

    TetromPH = zer;

    row = floor(p/4)+1;
    col = mod(p,4)+1;

    TetromPH(row, col) = 1;
    TetromPH(row + 1, col) = 1; 
    TetromPH(row, col + 1) = 1;
    TetromPH(row, col + 2) = 1;
    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+282) = TetromPH;
        TeLCount = TeLCount + 1;
    else
        Tetrom(:,:,p+282) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+282) = 1;
    end
end

%L flipped

for p = 0:19

    TetromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TetromPH(row, col +1) = 1;
    TetromPH(row + 1, col + 1) = 1;
    TetromPH(row + 2, col + 1) = 1;
    TetromPH(row + 2, col) = 1;
    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+302) = TetromPH;
        TeLCount = TeLCount + 1;
    else
        Tetrom(:,:,p+302) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+302) = 1;
    end
end

%L flipped rotate 90 deg ccw

for p = 0:19

    TetromPH = zer;

    row = floor(p/4)+1;
    col = mod(p,4)+1;

    TetromPH(row, col) = 1;
    TetromPH(row, col + 1) = 1; 
    TetromPH(row, col + 2) = 1;
    TetromPH(row + 1, col + 2) = 1;
    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+322) = TetromPH;
        TeLCount = TeLCount + 1;
    else
        Tetrom(:,:,p+322) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+322) = 1;
    end
end

%L flipped rotate 180 deg

for p = 0:19

    TetromPH = zer;

    row = floor(p/5)+1;
    col = mod(p,5)+1;

    TetromPH(row, col) = 1;
    TetromPH(row, col + 1) = 1;
    TetromPH(row + 1, col) = 1;
    TetromPH(row + 2, col) = 1;
    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+342) = TetromPH;
        TeLCount = TeLCount + 1;
    else
        Tetrom(:,:,p+342) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+342) = 1;
    end
end

%L flipped 90 deg rotation cw

for p = 0:19

    TetromPH = zer;

    row = floor(p/4)+1;
    col = mod(p,4)+1;

    TetromPH(row, col) = 1;
    TetromPH(row + 1, col) = 1; 
    TetromPH(row + 1, col + 1) = 1;
    TetromPH(row + 1, col + 2) = 1;
    C = TetromPH + B;
    Two = sum(ismember(C,2));

    if Two == 0
        Tetrom(:,:,p+362) = TetromPH;
        TeLCount = TeLCount + 1;
    else
        Tetrom(:,:,p+362) = Os;
        TeCount = TeCount + 1;
        TeLoc(p+362) = 1;
    end
end


%Now that all possible matrices have been generated, the invalid matrices
%(the ones that are all ones) are thrown out, and the final Series matrices
%are formed using the locators. The final matrices will be
%6x6xNumber of valid matrices.

%Changing the locator vectors so that it is the index of the valid boards
%in their respective matrix

MLoc = find(MLoc - 1);
DLoc = find(DLoc - 1);
TrLoc = find(TrLoc - 1);
TeLoc = find(TeLoc - 1);

%Length of the Locator
ML = length(MLoc);
DL = length(DLoc);
TrL = length(TrLoc);
TeL = length(TeLoc);



%Creating 9 series, one for each type of polyomino each with a length that
%is the number of valid matrices.

MonomSeries = zeros(6,6,ML);
DomSeries = zeros(6,6,DL);
TromLSeries = zeros(6,6,TrLCount);
TromISeries = zeros(6,6,TrICount);
TetromLSeries = zeros(6,6,TeLCount);
TetromISeries = zeros(6,6,TeICount);
TetromSqSeries = zeros(6,6,TeSqCount); 
TetromZSeries = zeros(6,6,TeZCount);
TetromTSeries = zeros(6,6,TeTCount);


%Monomino series is simply generated by locating the valid matrices in
%Monom

    MonomSeries(:,:,:) = Monom(:,:,MLoc); 

%Domino series is simply generated by locating the valid matrices in Dom

    DomSeries(:,:,:) = Dom(:,:,DLoc);

%Tromino series
%this is split into two pieces so as to generate both the I and L series.
%The only issue is that you need to keep track of which entries in the
%locator correspond to which series, this is done using the counters and
%making sure that each is called in the same order that it was originally
%generated.

%I

    TromISeries(:,:,:) = Trom(:,:,TrLoc(1:TrICount));

%L

    TromLSeries(:,:,:) = Trom(:,:,TrLoc((TrICount+1):(TrICount+TrLCount)));


%Tetromino series
%This is split into five pieces for the same reason that the tromino series
%were split into two. It also has the same issue of keeping track of the
%correct entries in the locator fixed in the same way that it was for the
%trominoes, though it becomes slightly cumbersome.


%I

    TetromISeries(:,:,:) = Tetrom(:,:,TeLoc(1:TeICount));

%Square

    TetromSqSeries(:,:,:) = Tetrom(:,:,TeLoc((1:TeSqCount)+TeICount));

%T

    TetromTSeries(:,:,:) = Tetrom(:,:,TeLoc((1:TeTCount)+TeICount+TeSqCount));

%Z

    TetromZSeries(:,:,:) = Tetrom(:,:,TeLoc((1:TeZCount)+TeICount+TeSqCount+TeTCount));

%L

    TetromLSeries(:,:,:) = Tetrom(:,:,TeLoc((1:TeLCount)+TeICount+TeSqCount+TeTCount+TeZCount));

%Number of polyomino matrices
PolyNum = ML + DL + TrL + TeL;

end